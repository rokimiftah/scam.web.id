--- a/src/features/voice/VoiceAssistantIntegrated.tsx
+++ b/src/features/voice/VoiceAssistantIntegrated.tsx
@@ -47,6 +47,7 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 		const [assistantResponse, setAssistantResponse] = useState("");
 		const [isThinking, setIsThinking] = useState(false);
 		const vapiRef = useRef<Vapi | null>(null);
+		const processedToolCallsRef = useRef<Set<string>>(new Set());
 
 		// Fetch data for the assistant to use
 		const scamStories = useQuery(api.scams.getScamStories, { limit: 100 });
@@ -205,18 +206,13 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 				}
 
 				try {
-					const messageContent = {
-						toolCallId,
-						functionName,
-						...payload,
-					};
-
 					vapiRef.current.send({
 						type: "add-message",
 						message: {
 							role: "tool",
 							name: functionName,
 							tool_call_id: toolCallId,
-							content: JSON.stringify(messageContent),
+							content: payload.result || payload.error || "Tool execution completed",
 						},
 						triggerResponseEnabled: true,
 					} as any);
@@ -227,7 +223,7 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 			[],
 		);
 
-		const handleFunctionCall = useCallback((functionName: string, rawArgs: any) => {
+		const handleFunctionCall = useCallback(async (functionName: string, rawArgs: any) => {
 			const args = parseFunctionArgs(rawArgs);
 			const countryArg = typeof args.country === "string" ? args.country.trim() : "";
 			const latestOnLocationQuery = onLocationQueryRef.current;
@@ -267,10 +263,10 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 				case "sendPreventionTipsEmail": {
 					if (countryArg) {
 						try {
-							latestSendTipsAction({ country: countryArg });
+							await latestSendTipsAction({ country: countryArg });
 							return {
 								success: true,
-								result: `Okay, I'm sending the prevention tips for ${countryArg} to the user's email.`,
+								result: `Okay, I've sent the prevention tips for ${countryArg} to your email.`,
 							};
 						} catch (error) {
 							console.error("Error triggering send prevention tips email:", error);
@@ -336,6 +332,7 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 		const attachVapiEventHandlers = useCallback(
 			(vapiInstance: Vapi) => {
 				vapiInstance.on("call-start", () => {
+					processedToolCallsRef.current.clear();
 					setIsListening(true);
 					setIsConnecting(false);
 					setTranscript("");
@@ -363,7 +360,7 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 					setIsThinking(false);
 				});
 
-				vapiInstance.on("message", (message: any) => {
+				vapiInstance.on("message", async (message: any) => {
 					// CRITICAL: Monitor for auto-end signals
 					if (message.type === "call-end" || message.type === "end-call") {
 						console.warn("ðŸš¨ UNEXPECTED CALL END DETECTED:", message);
@@ -380,10 +377,17 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 					}
 
 					if (message.type === "function-call") {
-						const result = handleFunctionCall(message.functionName, message.functionArgs);
-
 						const potentialToolCallId = message.toolCallId || message.tool_call_id || message.id || message.toolCall?.id;
+						
+						// Check if already processed to avoid duplicates
+						if (potentialToolCallId && processedToolCallsRef.current.has(potentialToolCallId)) {
+							console.log(`ðŸ”„ Skipping duplicate tool call: ${potentialToolCallId}`);
+							return;
+						}
+
+						const result = await handleFunctionCall(message.functionName, message.functionArgs);
+
 						if (potentialToolCallId) {
+							processedToolCallsRef.current.add(potentialToolCallId);
 							sendToolResultToVapi(potentialToolCallId, message.functionName ?? "", {
 								success: Boolean(result?.success),
 								result: result?.result,
@@ -398,16 +402,24 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 					// Also check for tool-calls format (alternative format)
 					if (message.type === "tool-calls" || message.toolCalls) {
 						const toolCalls = message.toolCalls || message.toolCallList || [];
 
-						toolCalls.forEach((toolCall: any) => {
+						// Use for...of to properly await async functions
+						for (const toolCall of toolCalls) {
 							const functionName = toolCall.name || toolCall.function?.name;
 							const rawArgs = toolCall.arguments || toolCall.function?.arguments;
 							const toolCallId = toolCall.id;
 
+							// Check if already processed to avoid duplicates
+							if (toolCallId && processedToolCallsRef.current.has(toolCallId)) {
+								console.log(`ðŸ”„ Skipping duplicate tool call: ${toolCallId}`);
+								continue;
+							}
+
 							if (functionName && rawArgs && toolCallId) {
-								const result = handleFunctionCall(functionName, rawArgs);
+								processedToolCallsRef.current.add(toolCallId);
+								const result = await handleFunctionCall(functionName, rawArgs);
 
 								// Forward the actual result from the handler so it works for all tools
-								// (Previously this always sent a "focused on" message which was only correct for location queries.)
 								sendToolResultToVapi(toolCallId, functionName, {
 									success: Boolean(result?.success),
 									result: (result as any)?.result,
@@ -416,7 +428,7 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 							} else {
 								console.warn("ðŸš¨ Incomplete tool call data:", { functionName, rawArgs, toolCallId });
 							}
-						});
+						}
 					}
 				});
 
