--- a/src/features/voice/VoiceAssistantIntegrated.tsx
+++ b/src/features/voice/VoiceAssistantIntegrated.tsx
@@ -47,6 +47,7 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 		const [assistantResponse, setAssistantResponse] = useState("");
 		const [isThinking, setIsThinking] = useState(false);
 		const vapiRef = useRef<Vapi | null>(null);
+		const processedToolCallsRef = useRef<Set<string>>(new Set());
 
 		// Fetch data for the assistant to use
 		const scamStories = useQuery(api.scams.getScamStories, { limit: 100 });
@@ -217,7 +218,7 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 							role: "tool",
 							name: functionName,
 							tool_call_id: toolCallId,
-							content: JSON.stringify(messageContent),
+							content: payload.result || payload.error || "Tool execution completed",
 						},
 						triggerResponseEnabled: true,
 					} as any);
@@ -228,7 +229,7 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 			[],
 		);
 
-		const handleFunctionCall = useCallback((functionName: string, rawArgs: any) => {
+		const handleFunctionCall = useCallback(async (functionName: string, rawArgs: any) => {
 			const args = parseFunctionArgs(rawArgs);
 			const countryArg = typeof args.country === "string" ? args.country.trim() : "";
 			const latestOnLocationQuery = onLocationQueryRef.current;
@@ -268,13 +269,13 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 				case "sendPreventionTipsEmail": {
 					if (countryArg) {
 						try {
-							latestSendTipsAction({ country: countryArg });
+							await latestSendTipsAction({ country: countryArg });
 							return {
 								success: true,
-								result: `Okay, I'm sending the prevention tips for ${countryArg} to the user's email.`,
+								result: `Okay, I've sent the prevention tips for ${countryArg} to your email.`,
 							};
 						} catch (error) {
-							console.error("Error triggering send prevention tips email:", error);
+							console.error("Error sending prevention tips email:", error);
 							return {
 								success: false,
 								result: `Sorry, I was unable to send the email.`,
@@ -337,6 +338,7 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 		const attachVapiEventHandlers = useCallback(
 			(vapiInstance: Vapi) => {
 				vapiInstance.on("call-start", () => {
+					processedToolCallsRef.current.clear();
 					setIsListening(true);
 					setIsConnecting(false);
 					setTranscript("");
@@ -364,7 +366,7 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 					setIsThinking(false);
 				});
 
-				vapiInstance.on("message", (message: any) => {
+				vapiInstance.on("message", async (message: any) => {
 					// CRITICAL: Monitor for auto-end signals
 					if (message.type === "call-end" || message.type === "end-call") {
 						console.warn("ðŸš¨ UNEXPECTED CALL END DETECTED:", message);
@@ -381,10 +383,17 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 					}
 
 					if (message.type === "function-call") {
-						const result = handleFunctionCall(message.functionName, message.functionArgs);
-
 						const potentialToolCallId = message.toolCallId || message.tool_call_id || message.id || message.toolCall?.id;
+						
+						// Check if already processed to avoid duplicates
+						if (potentialToolCallId && processedToolCallsRef.current.has(potentialToolCallId)) {
+							console.log(`ðŸ”„ Skipping duplicate tool call: ${potentialToolCallId}`);
+							return;
+						}
+
+						const result = await handleFunctionCall(message.functionName, message.functionArgs);
+
 						if (potentialToolCallId) {
+							processedToolCallsRef.current.add(potentialToolCallId);
 							sendToolResultToVapi(potentialToolCallId, message.functionName ?? "", {
 								success: Boolean(result?.success),
 								result: result?.result,
@@ -399,16 +408,24 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 					if (message.type === "tool-calls" || message.toolCalls) {
 						const toolCalls = message.toolCalls || message.toolCallList || [];
 
-						toolCalls.forEach((toolCall: any) => {
+						// Use for...of instead of forEach to properly await async functions
+						for (const toolCall of toolCalls) {
 							const functionName = toolCall.name || toolCall.function?.name;
 							const rawArgs = toolCall.arguments || toolCall.function?.arguments;
 							const toolCallId = toolCall.id;
 
+							// Check if already processed to avoid duplicates
+							if (toolCallId && processedToolCallsRef.current.has(toolCallId)) {
+								console.log(`ðŸ”„ Skipping duplicate tool call: ${toolCallId}`);
+								continue;
+							}
+
 							if (functionName && rawArgs && toolCallId) {
-								const result = handleFunctionCall(functionName, rawArgs);
+								processedToolCallsRef.current.add(toolCallId);
+								const result = await handleFunctionCall(functionName, rawArgs);
 
 								// Forward the actual result from the handler so it works for all tools
-								// (Previously this always sent a "focused on" message which was only correct for location queries.)
+								// (Previously this always sent a "focused on" message which was only correct for location quer ies.)
 								sendToolResultToVapi(toolCallId, functionName, {
 									success: Boolean(result?.success),
 									result: (result as any)?.result,
@@ -417,7 +434,7 @@ const VoiceAssistantIntegrated = forwardRef<VoiceAssistantHandle, VoiceAssistant
 							} else {
 								console.warn("ðŸš¨ Incomplete tool call data:", { functionName, rawArgs, toolCallId });
 							}
-						});
+						}
 					}
 				});
 
